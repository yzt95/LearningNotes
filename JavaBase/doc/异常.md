## 概述
异常事件分为两类：Error 和 Exception
### Error
Java 虚拟机无法解决的严重问题：JVM 系统内部错误、资源耗尽，比如：StackOverflowError、OutOfMemoryError(OOM)，对于 Error 不编写代码进行处理
### Exception
因编程错误或偶然因素导致的一般性问题，可以编写代码进行处理，Exception 就是狭义上的异常，比如：空指针访问，试图读取不存在的文件，网络连接中断，数组索引越界
* 受检异常（checked）：编译期异常，编译器可以检查出来的异常，必须处理
* 非受检异常（unchecked）：运行时异常

## 常见异常

### 异常的体系结构
* java.lang.Throwable
    * java.lang,Error
    * java.lang.Exception
        * checked
            * IOException
                * FileNotFoundException
                * ...
        * unchecked
            * NullPointerException
            * ArrayIndexOutOfBoundsException
            * StringIndexOutOfBoundsException
            * ClassCastException(强转类型时)
            * NumberFoarmatException（将非数值的字符串通过包装类的parse方法转成数值）
            * InputMismatchException（使用Scanner输入不匹配）
            * ArithmeticException（除以0）

## 异常处理机制：try-catch-finally
### 抓抛模型
* 抛：程序在正常执行过程中，如果出现了异常，会在异常代码处生成一个对应的**异常类的对象**，并将此对象抛出，一旦抛出此对象，其后的代码不会继续执行，这些抛出的异常对象可以是系统自动生成的，也可以手动抛出
* 抓：异常处理方式
    * try-catch-finally
    * throws

```java
try {
    // 可能出现异常的代码
}catch(异常类型1 变量名) {
    // 异常处理方式1
}catch(异常类型2 变量名) {
    // 异常处理方式2
}catch(异常类型3 变量名) {
    // 异常处理方式3
}
...
finally {
    // 可选结构
    // 一定会执行的代码 
}
```
### 说明
* try{} 中的代码是可能出现异常的，在执行过程中，一旦出现异常，会根据此异常对象的类型去 catch(){} 中匹配，如果匹配成功，就会进入相应的 catch(){} 进行处理，一旦处理完成，就跳出 try-catch 结构，继续执行 try-catch 后的代码(如果没有 finally{} 的话)
* catch(){} 参数中的异常类型，如果没有子父类关系，谁声明在上，谁声明在下都可以，但如果有子父类关系，父类异常必须要**在子类异常后面**
* try{} 结构中声明的变量，在结构外面不可用
* catc(){} 中常用处理方式：String getMessage();printStackTrace();
* 使用 try-catch-finally 结构解决的是编译期异常，但在运行时依然可能出现异常，相当于延迟异常的出现
### finally 结构的作用
其中声明一定会执行的代码。即使 catch(){} 中又出现了没有处理的异常，或者 try{} 中有return语句，或者 catch(){} 中有return语句。所以，finally{} 中一般声明：手动释放数据库连接，IO流，网络编程 Socket等资源，因为这些资源的释放 JVM 是无能为力的。

## 异常处理机制：throws
throws + 异常类型写在方法的声明处，指明此方法执行时，可能会抛出异常，并抛给调用此方法的方法去处理，本质上并没有处理异常
```java
public class ExceptionTest {
    public static void main(String[] args) {
        try {
            method2();
        }catch(IOException e) {
            e.printStackTrace;
        }
    }
    
    public static void method2() throws IOException {
        method1();
    }
    
    public static void method1() throws FileNotFoundException,IOException {
        File file = new File("hello.txt");
        FileInputStream fis = new FileInputStream(file);
        int data = fis.read();
        while(data!=-1) {
            System.out.println((char)data);
            data = fis.read();
        }
        fis.close();
    }
}
```
### 如何选择抛出异常的两种方式
1. 如果父类中被重写的方法没有使用 throws 方式处理异常，则子类重写的方法也不能使用 throws，因为子类重写方法抛出的异常不可大于父类，意味着如果重写方法中有异常，则必须使用 try-catch-finally 方式处理
2. 当连续调用几个其他方法 abc，且 abc 的执行是递进的（c的参数依赖b，b的参数依赖a），这时不要在方法 abc 内部使用 try-catch-finally，而是统一向上 throws，由调用者统一处理

## 手动抛出异常：throw
```java
public class StudentTset {
    public static void main(String[] args) {
        Strudent stu = new Student;
        // 真正处理掉异常
        try {
            stu.regist(-1);
        }catch(Exception e) {
            System.out.println(e.getMessage);
        }
    }
}

// 表示该类内部会存在没有使用try-catch处理的异常
class Student throws Exception{
    private int id;
    public void regist(int id) {
        if(id > 0) {
            this.id = id;
        }else {
            // 手动抛出异常
            throw new Exception("输入非法！");
        }
    }
}
```

## 自定义异常类
1. 继承现有的异常结构 RuntimeException 或 Exception
2. 提供全局 long 型常量：serialVersionUID
3. 提供重载的构造器

```java
public class MyException extends RuntimeException {
    static final long serialVersionUID = -31827614651784L;

    public MyException() {

    }

    public MyException(String msg) {
        super(msg);
    }
}
```